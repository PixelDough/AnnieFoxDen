export const data = [
	{
		slug: "sugar-plum-fairy",
		title: "Codename: Sugar Plum Fairy",
		status: "On Hold",
		date: "2024/12",
		collaborators: ["Jenna Bresky", "Elias Hatzandonis"],
		content: "<p>This is a game about a little robot who has to explore procedurally generated dungeons in search of batteries to continue to the next floor. After grabbing the first battery on a floor, a countdown timer starts. The player must collect enough batteries within the level to power the elevator and get out before the timer ends.</p><p>The little robot has extremely low health. Just two hits and it breaks. The player defends theirself from enemies by parrying attacks, which builds up a static charge, and quickly discharging onto an enemy.</p><p>One of my favorite parts about the game is the fact that it uses 100% custom lighting and shading. I have my own light source objects with various parameters that let me customize their visuals, including an HDR gradient to define how objects should be lit based on the calculated lighting value in the shader. It's pretty decently optimized too, only regenerating the gradient and texture data when changed. Because the lighting is rather simple, I'm actually able to process quite a few lights at once.</p><p>We started working on it near the end of 2024. The plan was for this to be UmeYume's first commercially released game. Due to scheduling issues with the team, it is currently unfinished.</p>",
		tools: "C#, Unity, Blender",
		videoIds: ["1050650536", "1050634544", "1050636821", "1050650218", "1050650858"],
		pictures: [],
	},
	{
		slug: "bugbounce",
		title: "Bugbounce",
		status: "On Hold",
		date: "2020 - Present",
		collaborators: ["FLOOR BABA"],
		content: "<p>Roll and bounce your way to the finish line in this physics-based precision platformer! Help Millie the Roly-Poly bounce through eight challenging stages. By bouncing off of walls with the right speed, trajectory, and velocity, Millie can gain incredible speed and altitude to cross gaps and overcome obstacles.</p><p>This game has a lot that's more intersting to play than to talk about. The game is all physics based. The player can roll around and jump and bounce off surfaces. If you hit a wall going fast enough into it, you'll gain extra height and speed. This core mechanic is used to make tight and challenging platforming levels. However, it also means the player is completely free to experiment and find their own route through a level. Getting the medals for speedrunning levels requires the player to find obscure ways through levels. Just the right combination of bounces can send the player flying across the level at breakneck speeds!</p><p>Shading in the game is done through a custom gradient-based system, and an abundance of matcap reflections where the surface depands a more reflective material. I'm also using a combination of coroutines and async/await in a way that allows me to pause gameplay while having another copy of the player loaded in to control the physics-based pause screen.</p><p>For the music, I've had the honor to work with the fantastic FLOOR BABA!</p>",
		tools: "C#, Unity, Blender",
		videoIds: ["1051758942", "1051758934", "1051758928", "1051758920", "1051758916"],
		pictures: [],
	},
	{
		slug: "moonlit-sonata",
		title: "Moonlit Sonata",
		status: "On Hold",
		date: "2022 - Present",
		collaborators: [],
		content: "<p>Sent to a distant moon to repair a base's facilities, you must utilize the terminals in your observation deck to conduct research and complete tasks, all while ensuring the outmoded malfunctional androids don't cause your demise...</p><p>Moonlit Sonata is probably my main passion project. A game I've continued to come back to and work on year after year. The core gameplay gimmick is that it only supports keyboard input. You have a monitor with a terminal on it, and several other monitors you can control with said terminal. The player has to read through \"man pages\" and use \"--help\" on various commands to learn how to complete their tasks, how to control their interfaces, as well as how to defend theirself.</p><p>A bit of story: These robots aren't evil. Many years prior, a passing cruise ship ejected them, and they crash landed on this moon. The damage to their processors caused them to lose many of their critical thinking skills. They now roam the moon for all eternity, chasing the light of the sun for solar energy to keep themselves alive. With the abandoned lunar base being brought back online, they flock there in hopes of being able to find work again, and be loved again. But when their power runs low, they get desperate and make rash decisions, lashing out on mankind for the way they've been treated.</p><p>The development of this project has a fairly long history. Originally, I considered making it use realtime graphics in Unity's HDRP, but I was unable to get the results I wanted. So I started learning how to render things in Blender, a skill which I had no experience in prior to this project. I learned how to use Blender to render out a scene and its depth map separately, and designed a shader that would let me have a model be obstructed by scenery in the pre-rendered scene. However, I wanted much more detailed shading on the characters too, and so I learned how to make blender render out the characters separately from the scene. The result was a texture for the scene, and two images for the characters: Their color, and their indirect lighting influence map. With these three images, I made a shader that would allow me to combine any number of characters onto the scene, each rendered as their own files. The benefit of this was being able to render each character only once, rather than needing to render out every single combination of character which would have had a much lengthier iteration time. However, around when I started noticing flaws in my rendering system, I decided on a different style for my renders. I wanted to make them lower resolution, with a much more limited color palette applied in post with Error Diffusion Dithering. The style looked so much nicer, and it made the render times short enough that I can easily render every combination of character in a scene to a separate texture file without very long render times, all automated via python scripting in Blender.</p><p>I wanted more for the terminal in game, however. My fake terminal was fine, but it was rather tricky to make any sort of ascii application with it, with proper monospace character alignment and state management. So I looked to a framework called \"sadconsole\". Switching over to Monogame would allow me to use sadconsole for my game's terminal, and because my game is mainly pre-rendered graphics anyways, it would actually be easier to draw those scenes in Monogame than in Unity, which tends to make directly drawing textures a bit of a pain. I already have experience working with 3D rendering in Monogame, so rendering the monitors in 3D as I was doing in Unity would not be very hard.</p><p>I have lots of plans for this game. I basically have most of the game planned out. Hopefully, some day, I will be able to finish it!</p>",
		tools: "C#, Unity/Monogame, Blender",
		videoIds: [],
		pictures: ["$lib/assets/portfolio/MS_01.png", "$lib/assets/portfolio/MS_02.png", "$lib/assets/portfolio/MS_03.png", "$lib/assets/portfolio/MS_04.png", "$lib/assets/portfolio/MS_05.png", "$lib/assets/portfolio/MS_Map_01.png", "$lib/assets/portfolio/MS_Map_02.png"],
	},
	{
		slug: "sub-vr",
		title: "Sub VR",
		status: "Prototype",
		date: "2024/08",
		collaborators: [],
		content: "<p>What began as an attempt to learn how to make VR games evolved into another version of my Underwater ROV exploration game ideas. But after some brainstorming, I ended up having a much more interesting idea! This prototype featured the player controlling a microscopic submersible vehicle throughout the human body. Their job would be to travel through the blood veins into various organs and places in the body, locating out-of-place objects, cleaning, and extracting them.</p><p>Unity's VR tools have improved quite a lot since the last time I tried my hand at VR game development. Some things still required a lot of problem solving, due to the specifics of the project having physics controlled interfaces within a much larger physics object in scene.</p>",
		tools: "C#, Unity, Blender",
		videoIds: [],
		pictures: ["$lib/assets/portfolio/SubVR_01.png", "$lib/assets/portfolio/SubVR_02.png", "$lib/assets/portfolio/SubVR_03.png"],
	},
	{
		slug: "night-knight",
		title: "Night Knight",
		status: "Prototype",
		date: "2024/06",
		collaborators: [],
		content: "<p>This was a very short prototype of using HDRP in a more low-fidelity context. I was dealing with development burnout and wanted something to artistically satisfy me without actually working on a \"game\".</p><p>I did eventually have some development ideas for it, but in an effort to not worsen my burnout, I moved on. Something about ghosts and haunted castles and figuring out how to banish each ghost of each castle. I think I had been reading a lot of ancient medieval ghost stories and found inspiration there.</p>",
		tools: "C#, Unity, Blender",
		videoIds: [],
		pictures: ["$lib/assets/portfolio/NK_01.png", "$lib/assets/portfolio/NK_02.png"],
	},
	// {
	// 	slug: "flippad-studio",
	// 	title: "Flippad Studio",
	// 	status: "Prototype",
	// 	date: "2024/01 - 2024/06",
	// 	collaborators: [],
	// 	content: "",
	// 	tools: "Swift, SwiftUI, Xcode",
	// 	videoIds: [],
	//  pictures: [],
	// },
	// {
	// 	slug: "bat-game",
	// 	title: "Bat Game",
	// 	status: "Prototype",
	// 	date: "2024/04",
	// 	collaborators: [],
	// 	content: "",
	// 	tools: "C#, Monogame",
	// 	videoIds: [],
	//  pictures: [],
	// },
	// {
	// 	slug: "desert-mail",
	// 	title: "Desert Mail",
	// 	status: "Prototype",
	// 	date: "2024/03",
	// 	collaborators: [],
	// 	content: "",
	// 	tools: "C#, Unity, Blender",
	// 	videoIds: [],
	//  pictures: [],
	// },
	// {
	// 	slug: "alien-ocean",
	// 	title: "Alien Ocean",
	// 	status: "Prototype",
	// 	date: "2024/02",
	// 	collaborators: [],
	// 	content: "",
	// 	tools: "C#, Unity, Blender",
	// 	videoIds: [],
	//  pictures: [],
	// },
	// {
	// 	slug: "aquasonix-hydromite",
	// 	title: "Aquasonix: Hydromite",
	// 	status: "On Hold",
	// 	date: "2023 - 2024/01",
	// 	collaborators: [],
	// 	content: "",
	// 	tools: "C#, Unity, Blender",
	// 	videoIds: [],
	//  pictures: [],
	// },
	// {
	// 	slug: "multiplayer-maze",
	// 	title: "Multiplayer Maze",
	// 	status: "Prototype",
	// 	date: "2023/11",
	// 	collaborators: [],
	// 	content: "",
	// 	tools: "C#, Unity, Blender",
	// 	videoIds: [],
	//  pictures: [],
	// },
	// {
	// 	slug: "galaxinet-contractor",
	// 	title: "galaxinet-contractor",
	// 	status: "On Hold",
	// 	date: "2023/05",
	// 	collaborators: [],
	// 	content: "",
	// 	tools: "C#, Unity, Blender",
	// 	videoIds: [],
	//  pictures: [],
	// },
];